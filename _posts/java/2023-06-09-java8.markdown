---
permalink: /java/java8
title: "JAVA - 8"
categories:
  - java
tags:
  - java
  - eclipse
toc: true
toc_sticky: true
toc_label: "JAVA - 8"
---

![img](/images/java/java.jpg)

### 익명클래스 사용

```java
interface Anony {
    void print();
}

public class AnonyTest {
	public void printB(Anony a) {
		a.print();
	}
	public static void main(String[] args) {
		AnonyTest t = new AnonyTest();
		// printB() 메소드에 인자로 전달되는 것은
		// new Annoy()를 통해 만들어진 Annoy 인터페이스의 익명 구현 객체 입니다.
		t.printB(new Anony() {
			public void print() {
				System.out.println("익명 클래스 사용 중입니다.");
			}
		});
		// new Anony() { 하나의 인자입니다.
		// 	public void print(){
		// 	System.out.println("익명클래스 사용 중입니다.");
		// }
		//	}

		// new Anony() {...} 구문은 Anony 인터페이스를 구현한
		// 익명 클래스의 인스턴스를 생성하는 코드입니다.

		// 이 익명 클래스 인스턴스는 printB() 메소드의 인자로 전달되며,
		// 그 자체로 하나의 객체를 나타냅니다.
		t.printB(new Anony() {
			public void print() {
				System.out.println("안녕하세요.");
			}
		});

	}

}
```

Java에서 익명 클래스를 사용하는 예시입니다.

**`Anony`**라는 인터페이스가 정의되어 있습니다. 이 인터페이스는 **`print()`**라는 추상 메서드를 가지고 있습니다.

**`AnonyTest`** 클래스는 **`printB(Anony a)`**라는 메서드를 정의하고 있습니다. 이 메서드는 **`Anony`** 타입의 인자 **`a`**를 받아서 **`a.print()`**를 호출하는 역할을 합니다.

**`main()`** 메서드에서 **`AnonyTest`** 클래스의 인스턴스 **`t`**를 생성합니다. 그리고 **`t.printB()`** 메서드를 호출하는데, 이 때 익명 클래스를 사용합니다.

**`new Anony() {...}`** 구문은 **`Anony`** 인터페이스를 구현한 익명 클래스의 인스턴스를 생성하는 코드입니다. 중괄호 안에는 **`print()`** 메서드를 구현하고 그 안에서 출력문을 실행하는 내용이 작성되어 있습니다.

위의 코드에서는 두 번의 **`t.printB()`** 호출이 있습니다. 첫 번째 호출은 "익명 클래스 사용 중입니다."라는 출력을, 두 번째 호출은 "안녕하세요."라는 출력을 하게 됩니다.

이처럼 익명 클래스는 인터페이스나 추상 클래스를 구현하여 간단한 구현을 필요로 할 때 유용하게 사용될 수 있습니다.

### MultiTest.java

```java
interface ITest3 {
	public void func1();
}
interface ITest2 extends ITest3 {
	public abstract void func1();
}
interface ITest1 {
	public void test();
}
class Child implements ITest1, ITest2{

	public void test () {
		System.out.println("test() 메서드 입니다.");
	}
	public void func1() {
		System.out.println("func1() 메서드 호출");
	}
	public void func2() {
		System.out.println("func2() 메서드 호출");

	}
}

public class MultiTest {
	public static void main(String[] args) {
		Child c = new Child();
		ITest1 i1 = new Child();
		ITest2 i2 = new Child();
		c.test();
		c.func1();
		c.func2();
		System.out.println();

		i1.test();
		// i1.func1();	// 오류발생
		// i1.func2();
		i2.func1();
	}
}
```

Java에서 다중 인터페이스와 상속을 사용하는 예시입니다.

- **`ITest3`** 인터페이스는 **`func1()`**이라는 추상 메서드를 가지고 있습니다.
- **`ITest2`** 인터페이스는 **`ITest3`**를 상속하며, **`func1()`** 메서드를 재정의합니다.
- **`ITest1`** 인터페이스는 **`test()`**라는 추상 메서드를 가지고 있습니다.
- **`Child`** 클래스는 **`ITest1`**과 **`ITest2`**를 구현합니다. 따라서 **`Child`** 클래스는 **`test()`**, **`func1()`**, **`func2()`** 메서드를 구현해야 합니다.

**`main()`** 메서드에서는 다음과 같은 작업을 수행합니다:

1. **`Child`** 클래스의 인스턴스 **`c`**를 생성합니다.
2. **`ITest1`** 타입의 인터페이스 변수 **`i1`**을 선언하고, **`Child`** 인스턴스를 할당합니다.
3. **`ITest2`** 타입의 인터페이스 변수 **`i2`**를 선언하고, **`Child`** 인스턴스를 할당합니다.
4. **`c`** 객체의 **`test()`**, **`func1()`**, **`func2()`** 메서드를 호출하여 각각의 결과를 출력합니다.
5. **`i1`** 객체의 **`test()`** 메서드를 호출하여 결과를 출력합니다. **`i1`**은 **`ITest1`** 타입이기 때문에 **`func1()`**과 **`func2()`**를 호출할 수 없습니다.
6. **`i2`** 객체의 **`func1()`** 메서드를 호출하여 결과를 출력합니다.

### 제네릭

```java
public class 제네릭 {
	// 자바에서 "제네릭"은 다양한 타입의 객체를 다루는 메서드나 컬렉션 클래스에
	// 컴파일 시 타입 체크를 해주는 기능입니다.
	// 제네릭을 사용하면, 클래스나 메서드 내부에서 사용할 데이터 타입을 외부에서 지정할 수 있게 되어
	// 코드의 재사용성을 높이고 타입 안정성을 확보할 수 있습니다.

	List<String> list = new ArrayList<String>();

	//	list 변수에는 String 객체만 추가할 수 있으며,
	//	다른 타입의 객체를 추가하려고 하면 컴파일 오류가 발생
	//	제네릭을 사용하면 프로그램의 타입 안정성을 보장
	// 배열은 고정된 크기의 동일한 타입의 요소들을 저장할 수 있습니다.
	// 제네릭은 크기가 동적으로 변하는 <> 컬렉션 (ArrayList, LinkedList 등)에 사용되며,
	// 다양한 타입의 객체를 저장하고 처리할 수 있습니다.
	// 컬렉션은 객체를 저장하므로, 기본 데이터 타입은 사용할 수 없고, 대신에
	// 래퍼클래스(Integer, Double, Character 등)를 사용해야 합니다.
	// -- 필요에 따라 배열과 제네릭을 혼합하여 사용하면 됩니다.
	// 특정 타입만 다루지 않고, 여러 종류의 타입으로 변신할 수 있도록
	// 클래스나 메소드를 일반화시키는 기법 <E>, <K>, <V> : 타입 매개 변수

	// 제네릭을 사용하는 이유
	// 컴파일 단계에서 잘못된 타입을 사용할 수 있는 문제를 제거한다.
	// 컬렉션에 저장된 여러 종류의 객체를 꺼내서 사용할 때 객체의 종류에 따라
	// 매번 형변환을 해야 하기 때문에 코드가 복잡해진다.
	// 컬렉션, 람다식(함수적 인터페이스), 스트림, NIO에서 널리 사용한다.
	// 제네릭을 모르면 API Document 해석이 어렵기 때문에 학습에 제한이 생긴다

	// 제네릭 타입은 두 개 이상의 타입 파라미터를 사용 가능하다.
	// 각 타입 파라미터는 콤마로 구분하여 사용하면 된다.

	// 제네릭스 타입을 부모 클래스로 사용해야 할 경우에는,
	// 타입 파라미터는 자식 클래스에도 기술해야 하며, 추가적인 타입 파라미터를 가질 수 있다.
	// public class ChildProduct<T, M> extends Product<T, M>{ ... }
	// public class ChildProduct<T, M, C> extends Product<T, M, C>{ ... }


}
```

```java
//<T>로 활용되며, 어떤 변수 타입이 오더라도 활용이 가능하다.
//전달받을 변수 타입이 정해지지 않았을 때 사용 가능하다.
interface MyFunction6<T>{
	// 인수에서 전달하는 변수 타입에 따라 String이 될 수도 있고 Integer가 될 수도 있다.
	// 이런 대문자 변수들을 랩퍼 클래스라고 하며
	// 랩퍼 클래스 변수는 자체로 클래스가 된다. (이미 정의되어 있기 때문에 별도의 선언은 불필요하다.)
	void print(T x);
}
public class Ex_08 {
	public static void main(String[] args) {
		// 여기서 변수 타입은 String
		// toString 메소드를 통해 객체에 저장된 값을 출력할 수 있다.
		MyFunction6<String> f1 = (x) -> System.out.println(x.toString());
		f1.print("ABC");
		// 여기서는 Integer로 서로 다르지만 변수 타입을 제네릭 변수로 받기 때문에 문제 없다.
		// toString 메소드는 문자열만 출력 가능하기 때문에
		// Integer 변수의 경우 별도의 작업을 거쳐야 출력이 가능하다.
		// 랩퍼 객체로 변환은 valueOf 메소드를 (Boxing)
		// int로 변환은 parseInt()를 활용한다. (UnBoxing)
		MyFunction6<Integer> f2 = (x) -> System.out.println(x.toString());
		f2.print(Integer.valueOf(100));
	}
}
//제네릭은 타입인가?
//제네릭은 자바에서 데이터 타입을 파라미터화(Parameterize) 할 수 있는 방법을 제공하는
//프로그래밍 기법입니다. 그 자체로 타입은 아니지만, 클래스나 인터페이스, 메서드를 정의할 때
//사용하는 타입 매개변수를 가리킵니다.
```

### 제네릭 2 - 단일 인자

```java
class MyClass<T>{
	private T t;
	public void set(T t) {
		this.t = t;
	}
	public T get() {
		return t;
	}


}
public class SingleGenericArgument {

	public static void main(String[] args) {
		MyClass<String> mc1 = new MyClass<String>();
		mc1.set("안녕");
		System.out.println(mc1.get());
		MyClass<Integer> mc2 = new MyClass<>();
		mc2.set(100);
		System.out.println(mc2.get());
//		 MyClass<Integer> mc3 = new MyClass<>();
//		 mc3.set("안녕");		// 오류 강한타입 체크
	}

}
```

**`MyClass<T>`**는 제네릭 클래스로, 타입 매개변수 **`T`**를 사용합니다. 제네릭 클래스는 어떤 타입을 사용할 것인지를 나중에 결정할 수 있도록 합니다.

**`MyClass`** 클래스는 **`private T t;`**와 **`public void set(T t)`** 메서드, 그리고 **`public T get()`** 메서드를 가지고 있습니다. **`set()`** 메서드는 제네릭 타입 **`T`**의 인자를 받아서 **`t`** 필드에 할당하고, **`get()`** 메서드는 **`t`** 필드를 반환합니다.

**`main()`** 메서드에서는 다음과 같은 작업을 수행합니다:

1. **`MyClass<String>`** 타입의 인스턴스 **`mc1`**을 생성합니다. 이 때 **`T`**는 **`String`**으로 결정됩니다.
2. **`mc1`** 객체의 **`set("안녕")`** 메서드를 호출하여 값을 설정합니다.
3. **`mc1`** 객체의 **`get()`** 메서드를 호출하여 설정된 값을 출력합니다.
4. **`MyClass<Integer>`** 타입의 인스턴스 **`mc2`**를 생성합니다. 이 때 **`T`**는 **`Integer`**로 결정됩니다.
5. **`mc2`** 객체의 **`set(100)`** 메서드를 호출하여 값을 설정합니다.
6. **`mc2`** 객체의 **`get()`** 메서드를 호출하여 설정된 값을 출력합니다.
7. 주석 처리된 코드는 컴파일 오류를 발생시킵니다. **`mc3`**는 **`MyClass<Integer>`** 타입으로 선언되었기 때문에, **`set()`** 메서드에 문자열을 전달할 수 없습니다. 이는 제네릭의 강한 타입 체크에 의해 발생하는 오류입니다.

### 제네릭3 - 다중 인자

```java
class KeyValue<Key, Value>{

	private Key key;
	private Value value = null;

	public Key getKey() {
		return key;
	}
	public void setKey(Key key) {
		this.key = key;
	}
	public Value getValue() {
		return value;
	}
	public void setValue(Value value) {
		this.value = value;
	}


}
public class TwoGenericArguments {

	public static void main(String[] args) {
		KeyValue<String, Integer> kv1 = new KeyValue<>();
		kv1.setKey("사과");
		kv1.setValue(10000);
		String key1 = kv1.getKey();
		int value1 = kv1.getValue();
		System.out.println("key : " + key1 + " value : " + value1);

		KeyValue<Integer, String> kv2 = new KeyValue<>();
		kv2.setKey(404);
		kv2.setValue("Not Found(요청한 페이지를 찾을 수 없습니다.)");
		int key2 = kv2.getKey();
		String value2 = kv2.getValue();
		System.out.println("key : " + key2 + " value : " + value2);

		KeyValue<String, Void> kv3 = new KeyValue<>();
		// Void 타입은 null 만 가질 수 있는 타입
		kv3.setKey("키값만 사용");
		String key3 = kv3.getKey();
		System.out.println("key : " + key3 );

	}

}
```

Java에서 두 개의 제네릭 인자를 사용하는 예시입니다.

**`KeyValue<Key, Value>`**는 제네릭 클래스로, 두 개의 타입 매개변수 **`Key`**와 **`Value`**를 사용합니다. 이 클래스는 **`key`**와 **`value`**라는 필드를 가지고 있습니다.

**`getKey()`**와 **`setKey()`** 메서드는 **`key`** 필드에 접근하는 메서드이고, **`getValue()`**와 **`setValue()`** 메서드는 **`value`** 필드에 접근하는 메서드입니다.

**`main()`** 메서드에서는 다음과 같은 작업을 수행합니다:

1. **`KeyValue<String, Integer>`** 타입의 인스턴스 **`kv1`**을 생성합니다. **`Key`**는 **`String`** 타입, **`Value`**는 **`Integer`** 타입으로 결정됩니다.
2. **`kv1`** 객체의 **`setKey("사과")`**와 **`setValue(10000)`** 메서드를 호출하여 키와 값을 설정합니다.
3. **`kv1`** 객체의 **`getKey()`**와 **`getValue()`** 메서드를 호출하여 설정된 키와 값을 가져옵니다.
4. **`KeyValue<Integer, String>`** 타입의 인스턴스 **`kv2`**를 생성합니다. **`Key`**는 **`Integer`** 타입, **`Value`**는 **`String`** 타입으로 결정됩니다.
5. **`kv2`** 객체의 **`setKey(404)`**와 **`setValue("Not Found(요청한 페이지를 찾을 수 없습니다.)")`** 메서드를 호출하여 키와 값을 설정합니다.
6. **`kv2`** 객체의 **`getKey()`**와 **`getValue()`** 메서드를 호출하여 설정된 키와 값을 가져옵니다.
7. **`KeyValue<String, Void>`** 타입의 인스턴스 **`kv3`**를 생성합니다. **`Key`**는 **`String`** 타입, **`Value`**는 **`Void`** 타입으로 결정됩니다. **`Void`** 타입은 **`null`**만 가질 수 있는 타입입니다.
8. **`kv3`** 객체의 **`setKey("키값만 사용")`** 메서드를 호출하여 키 값을 설정합니다.
9. **`kv3`** 객체의 **`getKey()`** 메서드를 호출하여 설정된 키 값을 가져옵니다.

### 예외 처리

```java
// 다중 catch문의 특징
// - 자바 명령문이 많아지면 발생할 수 있는 Exception의 종류도 많아진다.
// - 다중 catch문은 순차적으로 해당 예외를 체크한 후에 예외 처리를 한다.
// 다중 catch문 구현시 Exception 계층 구조에서 상위 클래스 타입 매개변수를
// 가지는 catch문은 뒤에 위치시켜야 한다.
// 최상위 : Exception 	 상위 : IOExceptions  	하위 : FileNotException
// finally문 -- 예외 발생 유무와 관계없이 실행하는 부분

public class ExceptionTest1 {

	public static void main(String[] args) {
		try {
			int [ ] num = new int[2];
			num[0] = 1;
			num[1] = 2;
			num[2] = 3;				// ArrayIndexOutOfBoundsException 발생
//			num[1] = 3/0;			// ArithmeticException 발생
			System.out.println("Hello");
		} catch (ArrayIndexOutOfBoundsException e) {
			System.out.println("ArrayIndexOutOfBoundsException 처리");
		} catch (Exception e) {
			e.printStackTrace();
		}
		System.out.println("World");
	}

}
```

다중 catch문을 사용하여 예외 처리하는 예시입니다.

다중 catch문은 여러 종류의 예외를 처리하기 위해 사용됩니다. 코드 블록 안에서 예외가 발생할 수 있는 부분을 **`try`** 블록으로 감싸고, 발생한 예외에 따라 적절한 처리를 위해 **`catch`** 블록을 사용합니다.

코드의 실행 흐름은 다음과 같습니다:

1. **`try`** 블록 안에서 배열 **`num`**을 생성하고, 인덱스 0과 1에 값을 할당합니다.
2. **`num[2] = 3`**에서 **`ArrayIndexOutOfBoundsException`** 예외가 발생합니다. 이 예외는 배열 인덱스 범위를 벗어났을 때 발생합니다.
3. 예외 발생 후, 해당하는 **`catch`** 블록 중에서 해당 예외 타입과 일치하는 블록을 찾습니다. 첫 번째 **`catch`** 블록(**`ArrayIndexOutOfBoundsException`**)에 해당하므로, 해당 블록 안의 코드가 실행됩니다. "ArrayIndexOutOfBoundsException 처리"라는 메시지가 출력됩니다.
4. **`catch`** 블록 실행 후, 프로그램은 **`catch`** 블록 이후의 코드인 **`System.out.println("World")`**를 실행합니다. "World"가 출력됩니다.

다중 catch문에서 주의해야 할 점은 예외 클래스의 계층 구조에 따라 순서를 지정해야 한다는 점입니다. 상위 예외 클래스 타입을 가지는 **`catch`** 블록은 하위 예외 클래스 타입보다 뒤에 위치해야 합니다. 이는 상위 예외 클래스가 하위 예외 클래스의 부모 클래스이기 때문에, 상위 예외 클래스 타입의 **`catch`** 블록을 먼저 작성하면 모든 예외를 처리할 수 있게 됩니다. 만약 순서를 바꾼다면, 상위 예외 클래스 타입의 **`catch`** 블록에서 모든 예외를 처리하게 되고, 하위 예외 클래스 타입의 **`catch`** 블록은 실행되지 않습니다.

마지막으로, **`finally`** 블록은 예외 발생 여부와 관계없이 항상 실행되는 부분입니다. 위의 코드에는 **`finally`** 블록이 없으므로, 예외 발생 여부와 상관없이 "World"가 출력된 이후에 프로그램이 종료됩니다.

### 예외 처리2 - throw

```java
// throws 처리방식
// 예외 발생 시 발생한 예외를 메서드를 호출한 곳으로 전달하여 예외 처리를 한다.
// - 최초 메서드를 호출한 main() 메서드에서는 try/catch문으로 예외처리를 해야 한다.
// - RuntimeException 계열은 throws할 필요가 없다.

public class ExceptionTest2 {

	public static void main(String[] args) {
		try {
			int [ ] num = new int[2];
			num[0] = 1;
			num[1] = 2;
			System.out.println("Hello");
		} catch (ArrayIndexOutOfBoundsException e) {
			System.out.println("ArrayIndexOutOfBoundsException 오류 발생");
		} finally {	// 생략 가능 (무조건 하기때문에)
			System.out.println("오류 발생 유무와 무관하게 반드시 수행된다.");
		}
		System.out.println("World");
	}

}
```

**`throws`** 처리 방식을 사용하여 예외를 처리하는 예시입니다.

메서드에서 예외가 발생할 수 있는 부분을 **`try`** 블록으로 감싸고, 예외가 발생한 경우 해당 예외를 메서드를 호출한 곳으로 전달합니다. 이를 위해 예외를 **`throws`** 키워드를 사용하여 선언합니다.

위의 코드에서는 **`ArrayIndexOutOfBoundsException`** 예외가 발생할 수 있는 부분을 **`try`** 블록으로 감싸고, 예외가 발생한 경우 **`catch`** 블록에서 해당 예외를 처리합니다. **`finally`** 블록은 생략되어 있지만, **`finally`** 블록은 예외 발생 여부와 상관없이 항상 실행됩니다.

**`main()`** 메서드에서는 **`try-catch`** 구문을 사용하여 **`ArrayIndexOutOfBoundsException`** 예외를 처리합니다. 따라서 예외 발생 시 "ArrayIndexOutOfBoundsException 오류 발생"이 출력되고, **`finally`** 블록이 실행됩니다. 마지막으로 "World"가 출력됩니다.

**`RuntimeException`** 계열의 예외는 **`throws`**로 선언하지 않아도 됩니다. **`RuntimeException`**은 명시적인 예외 처리가 필요하지 않으며, 컴파일러가 체크하지 않습니다.

따라서 위의 코드는 "ArrayIndexOutOfBoundsException 오류 발생", "오류 발생 유무와 무관하게 반드시 수행된다.", "World"를 순서대로 출력합니다.
