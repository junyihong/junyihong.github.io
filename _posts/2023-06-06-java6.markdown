---
layout: post
title: 'Java - 6'
date: 2023-06-06 14:15:00 +0900
image: /java/java.jpg
tags: [java]
categories: JAVA
---

<hr/>

### 자바에서의 인터페이스

자바에서 인터페이스는 일종의 추상화된 클래스로, 메서드들의 집합을 정의하는 역할을 합니다. 인터페이스는 다음과 같은 특징을 가지고 있습니다:

1. 추상 메서드: 인터페이스는 추상 메서드만을 포함할 수 있습니다. 추상 메서드는 메서드의 선언부만을 포함하고, 구현 내용은 포함하지 않습니다. 이는 인터페이스를 구현하는 클래스에서 해당 메서드의 실제 구현을 제공해야 함을 의미합니다.
2. 다중 상속: 클래스는 다중 상속을 지원하지 않지만, 인터페이스는 다중 상속을 지원합니다. 클래스는 단일 클래스를 상속하면서 여러 개의 인터페이스를 구현할 수 있습니다. 이를 통해 다양한 기능을 조합하여 클래스를 설계할 수 있습니다.
3. 구현 강제: 인터페이스를 구현하는 클래스는 인터페이스에 정의된 모든 메서드를 구현해야 합니다. 즉, 인터페이스는 클래스가 가져야 할 동작을 강제하는 역할을 합니다. 이를 통해 코드의 일관성과 재사용성을 높일 수 있습니다.
4. 인터페이스 간 상속: 인터페이스 간에도 상속이 가능합니다. 인터페이스 A가 인터페이스 B를 확장(상속)하는 경우, 인터페이스 A는 인터페이스 B의 모든 메서드를 포함하게 됩니다. 이를 통해 인터페이스 간에도 계층 구조를 형성할 수 있습니다.

인터페이스는 다형성의 핵심 개념으로 사용되며, 클래스의 타입으로 사용될 수 있습니다. 또한 인터페이스를 구현하는 다양한 클래스들을 동일한 인터페이스 타입으로 다룰 수 있어, 유연하고 확장 가능한 코드를 작성할 수 있습니다.

<br/>

```java
// final 정의와 용도
// 정의
// - '금지'의 의미를 가지는 지정자다.
// 용도
// - 클래스 : 상속을 금지한다.
// - 멤버 메서드 : 오버라이딩을 금지한다.
// - 멤버 변수 : 값 변경을 금지한다. (상수로 사용).

// 인터페이스 정의
// interface 키워드로 선언된 추상 클래스

// 인터페이스 특징
// - 추상 클래스가 발전한 개념이다.
// - 인스턴스 생성이 불가능하다.
// - upcasting 타입으로 사용할 수 있다.
//   멤버로는 상수, 추상 메서드만 활용한다.
// - 하위클래스와의 관계는 implements이다.
// 하위 클래스에서는 여러 인터페이스를 동시에 implements 할 수 있다.
// - 자바의 단일 상속 기능을 보완할 수 있다.

// 인터페이스 용도
// - 기능만을 하위 클래스에 강제하기 위해 사용된다.

// 리모델링 법규집
// 1조 1항 : 모든 건물에는 비상구가 있어야 한다.
// 1조 2항 : 기존 방의 개수는 변경할 수 없다.
// 1조 3항 : 모든 건물에는 하나 이상의 화장실이 설치되어 있어야 한다.

// 추상 클래스의 변형, 인터페이스는 추상클래스와 유사하지만 클래스가 아니다.
// 클래스처럼 상속을 해주지만 클래스가 아니므로 다수의 인터페이스의 상속을 받는것도 가능하다.
// 인터페이스는 interface I_NAME 의 방식으로 선언하며,
// 인터페이스에서 상속은 class C_NAME implements I_NAME 방식으로 쓰인다.
// 추상클래스는 설계와 구현을 분리시키기 위해서 사용
```

---

### 인터페이스 사용예제

```java
interface PhoneInterface{
	// 인터페이스에서 선언되는 필드 변수는 모두 상수 변수이다. (final)
	// 아니어도 되지만 대부분 그렇게 사용함.
	final int TIMEOUT = 10000;
	void sendCall();
	void receiveCall();

	// default 메소드 : 인터페이스의 메소드 중 하나는 일반 클래스의 메소드처럼 동작이 정의될 수 있다.
	// default 메소드를 활용하면 자바에서도 다중상속을 할 수 있다.
	default void printLogo() { 	// default 메소드
	// interface 내부에 메소드, 맞기만 하면 가져다 쓸 수 있는 것이다.
		System.out.println("** Phone **");
	}
}
// 인터페이스 구현은 implements 키워드 활용
// 인터페이스는 두개의 오버라이딩을 받을 수 있는 것인가?
// 다중으로 인터페이스 다중 상속을 받을 수 있는 것!!

class SamsungPhone implements PhoneInterface {
	@Override
	public void sendCall() {
		System.out.println("띵띵땅땅 ~");
	}
	// 오버라이드 : 재정의 / 문법적으로 검사하는것
	@Override
	public void receiveCall() {
		System.out.println("전화왔어요 ~");
	}
	// @ 앳 이라고 불리운다. 어노테이션의 약어임.
	public void flash() {
		System.out.println("플래시 On");
	}
	// 추상클래스와 인터페이스는 객체생성을 할 수 없다.
}

public class Phone {
	public static void main(String[] args) {
		SamsungPhone phone = new SamsungPhone();
		phone.printLogo();
		phone.sendCall();
		phone.receiveCall();
		phone.flash();
	}
}
// 자체로는 객체 생성이 불가능하지만 이를 사용하려면
// 1 ) 추상클래스를 일반 클래스에 상속하여 객체를 생성할 수 있다.
// 2 ) 익명 이너클래스를 사용하면 컴파일러가 내부적으로 클래스를 생성한 후 메서드 오버라이드를 수행
// 		(클래스이름을 알 수 없다.) 1회용이다.
// 미완성 메서드로 완성하여 해당 객체를 생성할 수 있다.
```

<br/>

```java
interface MobliePhoneInterface extends PhoneInterface {
	// PhoneInterface Ex_02 예제에서 정의한 인터페이스
	void sendSMS();
	void recieveSMS();
}
interface MP3Interface{
	public void play();
	public void stop();
}
class PDA {
	public int calculate(int x, int y) {
		return x + y;
	}
}
class SmartPhone extends PDA implements MobliePhoneInterface, MP3Interface{
	@Override
	public void sendCall() {
		System.out.println("띵띵땅땅");
	}
	@Override
	public void receiveCall() {
		System.out.println("전화왔어요~");
	}
	@Override
	public void sendSMS() {
		System.out.println("문자갑니다.");
	}

	@Override
	public void recieveSMS() {
		System.out.println("문자왔어요~");
	}
	@Override
	public void play() {
		System.out.println("음악 재생합니다.");
	}
	@Override
	public void stop() {
		System.out.println("음악 중단합니다.");
	}
	public void schedule() {
		System.out.println("일정 관리합니다.");
	}
}
	public class Ex_03{
		public static void main (String[] args) {
			SmartPhone phone = new SmartPhone();
			phone.printLogo();
			phone.sendCall();
			phone.play();
			System.out.println("3과 5를 더하면 " + phone.calculate(3, 5) );
			phone.schedule();
		}
	}
```

---

### 내부클래스 사용 예제

```java
package practice01_0605;
// static 내부 클래스 정의
// 내부 클래스가 static으로 지정된 클래스
// 내부 클래스 멤버가 static으로 지정되었으면 내부 클래스도 반드시 static으로 지정해야 한다.

public class MyOuter1 {
	private String name;
	private int age;
	public MyOuter1( String name, int age ) {
		this.name = name;
		this.age = age;
	}
	public String getName() {
		return name;
	}
	public int getAge() {
		return age;
	}
	static class Inner {

		private String address;	// 자신만의 인스턴스 값을 가질 수 있다.
		static String tel= " 010-1111-2222 ";

		public Inner ( String address) {
			this.address = address;
		}

		public String getUserInfo() {
			// return name + "" + age; 는 에러가 난다. 외부클래스에서
			return "주소는: " + address + ", 전화번호 : "+ tel;
		}
	}
}
```

<br/>

```java
package practice01_0605;

public class MyOuterInnerTest {
	public static void main(String[] args) {
		// MyOuter1 myOuter = new MyOuter1("홍길동", 20);
		MyOuter1.Inner inner = new MyOuter1.Inner("세종시 세종구");
		System.out.println("고객정보 >> " + inner.getUserInfo());
	}
}
// 문 > static을 안쓰고 고객정보 이름 : 홍길동,  나이 : 20,  주소 : 세종시 세종구
```

static 내부 클래스를 사용하여 고객 정보를 출력하는 예제입니다.

1. **`MyOuter1`** 클래스:
   - **`MyOuter1`** 클래스는 외부 클래스로, 고객의 이름과 나이를 저장하는 멤버 변수를 가지고 있습니다.
   - 생성자를 통해 이름과 나이를 초기화합니다.
   - **`getName()`**과 **`getAge()`** 메서드를 통해 이름과 나이를 반환합니다.
   - **`static`**으로 정의된 **`Inner`** 내부 클래스를 포함합니다.
2. **`Inner`** 내부 클래스:
   - **`Inner`** 클래스는 **`MyOuter1`** 클래스의 정적(static) 내부 클래스입니다.
   - **`address`**라는 멤버 변수와 **`tel`**라는 정적(static) 멤버 변수를 가지고 있습니다.
   - 생성자를 통해 주소를 초기화합니다.
   - **`getUserInfo()`** 메서드를 통해 주소와 전화번호를 반환합니다. 외부 클래스의 이름과 나이에 접근할 수 없습니다.
3. **`MyOuterInnerTest`** 클래스:
   - **`main`** 메서드에서는 **`MyOuter1.Inner`**를 통해 **`Inner`** 클래스의 객체를 생성합니다.
   - **`getUserInfo()`** 메서드를 호출하여 고객 정보를 출력합니다.

주어진 코드에서는 **`Inner`** 클래스의 **`getUserInfo()`** 메서드에서 외부 클래스의 이름과 나이에 접근할 수 없으므로, "주소는: 세종시 세종구, 전화번호: 010-1111-2222"와 같이 주소와 정적 멤버 변수인 전화번호만 출력됩니다.

---
