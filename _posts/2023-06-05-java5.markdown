---
layout: post
title: 'Java - 5'
date: 2023-06-05 09:30:00 +0900
image: /java/java5.jpg
tags: [java]
categories: JAVA
---

<hr/>

### TIC-TAC-TOE.java

```java
import java.util.Scanner;

public class Tic_Tac_Toe {

	public static void main(String[] args) {
		char[][] board = new char[3][3];
		int x, y;
		Scanner scan = new Scanner(System.in);

		// 보드 초기화
		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 3; j++) {
				board[i][j] = ' ';
			}
		}
		do {
			// 보드 출력
			for (int i = 0; i < 3; i++) {
				System.out.println("   " + board[i][0] + "|    " + board[i][1] + "|   " + board[i][2]);
				if (i != 2) {
					System.out.println("----|-----|----");
				}
			}
			System.out.println("다음 수의 좌표를 입력하시오: ");
			x = scan.nextInt();
			y = scan.nextInt();
			if (board[x][y] != ' ') {
				System.out.println("잘못된 위치입니다. 다른 위치를 선택하세요.");
				continue;
			} else {
				board[x][y] = 'X';
			}
			// 비어있는 위치 찾기
			int i = 0, j = 0;
			
			for (i = 0; i < 3; i++) {
				for (j = 0; j < 3; j++) {
					if (board[i][j] == ' ') {
						break;
					}
				}
				if (board[i][j] == ' ') {
					break;
				}
			}
			if (i < 3 && j < 3) {
				board[i][j] = '0';
			}
		} while (true);
	}
}
```

TIC-TAE-TOE.java를 만들었으나 몇가지 문제가 있습니다.

1. **`ArrayIndexOutOfBoundsException`**: 사용자로부터 입력 받은 좌표 **`x`**와 **`y`**를 바탕으로 **`board[x][y]`**를 접근하는 부분에서 배열 인덱스 범위를 초과할 수 있습니다. 이는 사용자가 0, 1 또는 2 이외의 값을 입력할 때 발생할 수 있습니다.
2. 게임 종료 조건이 없음: 현재 코드에서는 무한 반복문(**`do-while`**)을 사용하고 있으며, 게임 종료 조건이 없어서 게임이 끝나지 않습니다.
3. 컴퓨터가 수를 놓는 로직이 누락됨: 컴퓨터가 자동으로 수를 놓는 부분이 없어서 게임이 사용자의 입력만으로 진행됩니다.

1. **`ArrayIndexOutOfBoundsException`**: 사용자로부터 입력 받은 좌표 **`x`**와 **`y`**를 바탕으로 **`board[x][y]`**를 접근하는 부분에서 배열 인덱스 범위를 초과할 수 있습니다. 이는 사용자가 0, 1 또는 2 이외의 값을 입력할 때 발생할 수 있습니다.
2. 게임 종료 조건이 없음: 현재 코드에서는 무한 반복문(**`do-while`**)을 사용하고 있으며, 게임 종료 조건이 없어서 게임이 끝나지 않습니다.
3. 컴퓨터가 수를 놓는 로직이 누락됨: 컴퓨터가 자동으로 수를 놓는 부분이 없어서 게임이 사용자의 입력만으로 진행됩니다.
<hr/>

### 수정된 TIC-TAC-TOE.java

```java
import java.util.Scanner;

public class Tic_Tac_Toe {
    public static void main(String[] args) {
        char[][] board = new char[3][3];
        int x, y;
        Scanner scan = new Scanner(System.in);
        // 보드 초기화
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                board[i][j] = ' ';
            }
        }
        boolean gameOver = false; // 게임 종료 여부를 저장하는 변수
        do {
            // 보드 출력
            for (int i = 0; i < 3; i++) {
                System.out.println("   " + board[i][0] + "|    " + board[i][1] + "|   " + board[i][2]);
                if (i != 2) {
                    System.out.println("----|-----|----");
                }
            }
            System.out.println("다음 수의 좌표를 입력하시오: ");
            x = scan.nextInt();
            y = scan.nextInt();
            // 좌표 유효성 검사
            if (x < 0 || x >= 3 || y < 0 || y >= 3) {
                System.out.println("잘못된 위치입니다. 다른 위치를 선택하세요.");
                continue;
            }
            if (board[x][y] != ' ') {
                System.out.println("잘못된 위치입니다. 다른 위치를 선택하세요.");
                continue;
            } else {
                board[x][y] = 'X';
            }
            // 게임 승리 조건 검사
            if (checkWin(board, 'X')) {
                System.out.println("사용자가 승리했습니다!");
                gameOver = true;
            } else if (isBoardFull(board)) {
                System.out.println("무승부입니다!");
                gameOver = true;
            } else {
                // 컴퓨터의 수를 놓는 부분
                int[] computerMove = getComputerMove(board);
                board[computerMove[0]][computerMove[1]] = 'O';
                // 게임 승리 조건 검사
                if (checkWin(board, 'O')) {
                    System.out.println("컴퓨터가 승리했습니다!");
                    gameOver = true;
                } else if (isBoardFull(board)) {
                    System.out.println("무승부입니다!");
                    gameOver = true;
                }
            }
        } while (!gameOver);
    }
    // 게임 승리 조건을 검사하는 함수
    public static boolean checkWin(char[][] board, char player) {
        // 가로, 세로, 대각선의 승리 조건을 확인합니다.
        for (int i = 0; i < 3; i++) {
            if (board[i][0] == player && board[i][1] == player && board[i][2] == player) {
                return true; // 가로 승리 조건
            }
            if (board[0][i] == player && board[1][i] == player && board[2][i] == player) {
                return true; // 세로 승리 조건
            }
        }
        if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {
            return true; // 왼쪽 위에서 오른쪽 아래로의 대각선 승리 조건
        }
        if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {
            return true; // 오른쪽 위에서 왼쪽 아래로의 대각선 승리 조건
        }
        return false;
    }
    // 보드가 가득 찼는지 확인하는 함수
    public static boolean isBoardFull(char[][] board) {
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (board[i][j] == ' ') {
                    return false; // 빈 공간이 있으면 보드가 가득 차지 않았음을 의미합니다.
                }
            }
        }
        return true; // 모든 공간이 채워져 있으면 보드가 가득 찼음을 의미합니다.
    }
    // 컴퓨터의 수를 놓는 함수 (임의의 위치에 놓습니다)
    public static int[] getComputerMove(char[][] board) {
        int[] move = new int[2];
        do {
            move[0] = (int) (Math.random() * 3); // 0, 1, 2 중 하나의 랜덤한 값을 선택합니다.
            move[1] = (int) (Math.random() * 3);
        } while (board[move[0]][move[1]] != ' '); // 빈 공간에 수를 놓을 때까지 반복합니다.
        return move;
    }
}
```

출력화면 : 

<img src="{{site.baseurl}}/images/java/1.png" alt="Image description" style="width: 30%; height: 30%; margin-bottom: 20px">

<hr/>

### City.java

```java

import java.util.Scanner;

public class City {
	private double populationAmount;
	private String name;
	private double growthRate;
	Scanner scan01 = new Scanner(System.in);

	public void readInput() {
		System.out.println("도시 이름을 입력하세요. : ");
		this.name = scan01.next();
		
		System.out.println("현재 인구 수를 입력하세요. : ");
		this.populationAmount = scan01.nextInt();
		
		System.out.println("인구 증가율을 입력하세요. : ");
		this.growthRate = scan01.nextInt();
	}
	public void writeOutput() {
		System.out.println(name + "의 인구가 " + (int)populationAmount + "명 이고, 인구 증가율이 " + growthRate + "% 일 때" );
	}
	public int computeFuturePopulation(int _years) {
		int count = _years;
		while((count > 0) && (populationAmount > 0)) {
			this.populationAmount = populationAmount + (growthRate/100) * populationAmount;
			count--;
		}
		// 예상 인구 반환
		if(populationAmount > 0)
			return (int)populationAmount;
		else 
			return 0;
	}
}
```

**`readInput()`** 메서드는 사용자로부터 도시 이름, 현재 인구 수, 인구 증가율을 입력받습니다.

**`writeOutput()`** 메서드는 도시의 이름, 현재 인구 수, 인구 증가율을 출력합니다.

**`computeFuturePopulation()`** 메서드는 주어진 년수에 따라 예상 인구를 계산합니다. 주어진 인구 증가율에 따라 인구를 계산하고, 주어진 년수만큼 반복하여 예상 인구를 계산합니다. 계산된 예상 인구를 반환합니다.

<hr/>

### CityDriver.java

```java
import java.util.*;

public class CityDriver {
	public static void main(String[] args) {
		Scanner scan01 = new Scanner(System.in);
		
		// City 객체 참조 변수
		City aCity;
		// 예상 인구
		int newPopulation;
		//계속 여부
		boolean again = true;
		// 사용자가 계속하기를 원하는 동안 도시의 10년 후 예상 인구를 계산한다.
		while(again)
		{
			// City 객체를 생성하고 aCity가 가리키게 한다.
			aCity = new City();
			
			System.out.println("기간을 입력하세요. 단위 : n (년)");
			int years = scan01.nextInt();
			
			// aCity의 도시 이름, 인구와 인구 증가율을 읽어 들인다.
			aCity.readInput();
			
			// aCity의 도시 이름, 인구와 인구 증가율을 출력한다.
			aCity.writeOutput();
			
			// aCity의 10년 후 인구를 계산한다.
			newPopulation = aCity.computeFuturePopulation(years);
			
			// aCity의 예상 인구를 출력한다.
			System.out.println(years + "년 후 예상 인구는 " + newPopulation + "명 입니다.");
			
			// 계속 여부를 입력 받는다.
			System.out.println("계속하기를 원하세요? (true or false) : ");
			again = scan01.nextBoolean();
		}
		scan01.close();
		System.out.println("프로그램을 종료합니다.");
	}
}
```

**`main()`** 메서드는 사용자로부터 계속하기 여부와 도시 정보를 입력받아 처리합니다.

- **`aCity`** 변수는 **`City`** 객체를 참조하기 위한 변수입니다.
- **`newPopulation`** 변수는 예상 인구를 저장하기 위한 변수입니다.
- **`again`** 변수는 계속하기 여부를 저장하기 위한 변수입니다.

사용자가 계속하기를 원하는 동안 다음 작업이 반복됩니다:

- **`aCity`** 객체를 생성합니다.
- 사용자로부터 예상 인구를 계산할 기간(년)을 입력받습니다.
- **`aCity`**의 도시 이름, 인구, 인구 증가율을 입력받습니다.
- **`aCity`**의 도시 이름, 인구, 인구 증가율을 출력합니다.
- **`aCity`**의 예상 인구를 계산합니다.
- 예상 인구를 출력합니다.
- 사용자에게 계속하기 여부를 입력받습니다.

프로그램이 종료되면 "프로그램을 종료합니다."라는 메시지가 출력됩니다.

<hr/>

### Button1.java

```java
import java.awt.Button;
import java.awt.Color;
import java.awt.FlowLayout;

import javax.swing.JFrame;

public class Button1 extends JFrame {
	Button1() {
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setTitle("대박");
		setLayout(new FlowLayout());
		Button btn1 = new Button("가위");
		Button btn2 = new Button("바위");
		Button btn3 = new Button("보");
		add(btn1);	// 버튼 추가
		add(btn2);
		add(btn3);
		btn1.setBackground(Color.CYAN);
		btn3.setForeground(Color.RED);	// 보 색깔만 레드
		btn2.setEnabled(false);			// 바위 사용안함
		setBackground(Color.PINK);
		setForeground(Color.BLUE);
		setSize(200, 200);
		setVisible(true);	// 보여주는 값을 참으로해서 보여주겠다.
	}	
	public static void main(String[] args) {
		new Button1();
		// main() 메소드에서 Button1 클래스 생성
		// Button1()생성자가 실행되므로 windows창이 출력
	}
}
```

**`Button1`** 클래스는 **`JFrame`**을 상속하고 있으며, 프레임에 버튼을 추가하고 설정하는 기능을 제공합니다.

- **`Button1()`** 생성자는 프레임의 초기 설정을 수행합니다.
- **`setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE)`**은 프레임을 닫을 때 프로그램을 종료하도록 설정합니다.
- **`setTitle("대박")`**은 프레임의 제목을 설정합니다.
- **`setLayout(new FlowLayout())`**는 프레임의 레이아웃을 플로우 레이아웃으로 설정합니다.
- **`Button`** 객체를 생성하고 버튼의 텍스트를 설정합니다.
- **`add(btn1)`**을 통해 버튼을 프레임에 추가합니다.
- **`setBackground(Color.CYAN)`**은 버튼의 배경색을 시안(Cyan)으로 설정합니다.
- **`setForeground(Color.RED)`**은 버튼의 전경색(글자색)을 빨강(Red)으로 설정합니다.
- **`setEnabled(false)`**은 해당 버튼을 사용하지 않도록 설정합니다.
- **`setBackground(Color.PINK)`**은 프레임의 배경색을 핑크(Pink)로 설정합니다.
- **`setForeground(Color.BLUE)`**은 프레임의 전경색(글자색)을 파랑(Blue)으로 설정합니다.
- **`setSize(200, 200)`**은 프레임의 크기를 설정합니다.
- **`setVisible(true)`**은 프레임을 화면에 보이도록 설정합니다.

**`main()`** 메서드에서 **`Button1`** 클래스를 생성하고 실행하면 프레임이 생성되고 버튼이 표시됩니다.

출력화면 : 

<img src="{{site.baseurl}}/images/java/2.png" alt="Image description" style="width: 30%; height: 30%; margin-bottom: 20px">


<hr/>

### MethodOverriding.java - 오버라이딩

```java
public class MethodOverridingEx {
	static void paint(Shape p) {
		p.draw();	// p가 가리키는 객체 내에 오버라이딩된 draw() 호출.
					// 동적 바인딩 : 메서드를 오버라이드(재정의)하는 데 사용
					// 실제 참조되는 인스턴스(자식 클래스)의 타입에 따라 결정됩니다.
	}
	public static void main(String[] args) {
		Line line = new Line();
		paint(line);
		paint(new Shape());
		paint(new Line());
		paint(new Rect());
		paint(new Circle());
	}
}
class Shape {	// 슈퍼 클래스
	public Shape next;
	public Shape() { next = null; }
	public void draw() {
		System.out.println("Shape");
	}
}
class Line extends Shape {
	public void draw() {	// 메소드 오버라이딩
		System.out.println("Line");
	}
}
class Rect extends Shape {
	public void draw() {	// 메소드 오버라이딩
		System.out.println("Rect");
	}
}
class Circle extends Shape {
	public void draw() {	// 메소드 오버라이딩
		System.out.println("Circle");	
	}
}

//---------------------------------------------------------------
실행결과: 

Line
Shape
Line
Rect
Circle
```

**`MethodOverridingEx`** 클래스는 **`paint()`** 메서드를 정의하고 있습니다. 이 메서드는 **`Shape`** 타입의 매개변수를 받고, 해당 객체의 **`draw()`** 메서드를 호출합니다. 이때, **`draw()`** 메서드는 **오버라이딩(재정의)**되었을 때 동적 바인딩(dynamic binding)을 통해 실제 참조되는 객체의 메서드가 호출됩니다.

**`Shape`** 클래스는 슈퍼 클래스로, **`next`**라는 멤버 변수와 **`draw()`** 메서드를 가지고 있습니다.

**`Line`**, **`Rect`**, **`Circle`** 클래스는 **`Shape`** 클래스를 상속받은 자식 클래스들로, 각각 **`draw()`** 메서드를 오버라이딩하여 재정의하고 있습니다.

**`main()`** 메서드에서는 다양한 객체를 생성하고 **`paint()`** 메서드에 넘겨줌으로써 다양한 오버라이딩된 **`draw()`** 메서드가 호출되는 것을 확인할 수 있습니다.

<hr/>

### MethodOverloading.java - 오버로딩

```java
public class MethodOverloading {
	String title;
	String author;
	// 아래 생성자의 매개변수 수가 다르다
	
	// 작자 미상일 경우 활용한다.
	// 즉, input 값, 매개변수가 하나일 때 활용
	public OverLoading(String t) {
		title = t;
		author = "작자미상";
	}
	// 아래 생성자는 작자를 알 때 사용한다.
	// 즉, input 값, 매개변수가 두 개일 때 활용
	public OverLoading(String t, String a) {
		title = t;
		author = a;
	}
	public static void main(String[] args) {
		// 두 클래스 모두 객체를 생성했으므로 static을 사용하지 않아도 된다.
		// 아래 두 객체는 서로 가는 방향이 다르다. 매개변수 수에 맞춰 간다.
			OverLoading littlePrince = new OverLoading("어린왕자", "생택쥐페리");
			OverLoading loveStory = new OverLoading("춘향전");
			System.out.println(littlePrince.title + " : " + littlePrince.author);
			System.out.println(loveStory.title + " : " + loveStory.author);
	}
}
```

**`MethodOverloading`** 클래스는 **`OverLoading`**이라는 클래스를 정의하고 있습니다. 이 클래스에는 **`title`**과 **`author`**라는 인스턴스 변수가 있습니다.

**`OverLoading`** 클래스에는 두 개의 생성자가 정의되어 있습니다. 첫 번째 생성자는 **`String t`**라는 하나의 매개변수를 받습니다. 이 생성자는 작자를 알 수 없을 때 사용됩니다. 따라서 **`author`** 변수는 "작자미상"으로 초기화됩니다.

두 번째 생성자는 **`String t`**와 **`String a`**라는 두 개의 매개변수를 받습니다. 이 생성자는 작자를 알 때 사용됩니다. **`title`** 변수는 **`t`**로, **`author`** 변수는 **`a`**로 초기화됩니다.

**`main()`** 메서드에서는 **`OverLoading`** 클래스의 객체인 **`littlePrince`**와 **`loveStory`**를 생성합니다. **`littlePrince`** 객체는 첫 번째 생성자를 사용하여 "어린왕자"와 "생택쥐페리"를 전달하고, **`loveStory`** 객체는 두 번째 생성자를 사용하여 "춘향전"만 전달합니다.

각 객체의 **`title`**과 **`author`** 값을 출력하면, 초기화된 값이 정상적으로 출력됩니다.

이 예제는 매개변수의 수에 따라 다른 생성자를 사용하여 객체를 초기화하는 메서드 **오버로딩**의 개념을 보여주고 있습니다. 메서드 오버로딩은 같은 이름의 메서드를 여러 개 정의하고, 매개변수의 수나 타입을 다르게 하여 다양한 상황에 맞게 메서드를 호출할 수 있도록 합니다.

<hr/>

### Upcasting.java  - 업캐스팅

```java
// 업캐스팅(upcasting)은 객체 지향 프로그래밍에서 특히 상속 계층에서 사용되는 개념
// 업캐스팅은 자식 클래스의 객체를 부모 클래스의 객체로 취급하는 것
// 업캐스팅이 자동으로 이루어진다.
class Animal {
	public void makeSound() {
		System.out.println("Animal is making a sound");
	}
}
class Dog extends Animal {
	@Override
	public void makeSound() {
		System.out.println("Dog is barking");
	}
	public void wagTail() {
		System.out.println("Dog is wagging its tail");
	}
}	// 부모 클래스를 선언하고 자식클래스를 생성하여 부모는 자식을 사용할 수 있다.
	
public class Upcasting {
	public static void main(String[] args) {
		Animal myAnimal = new Dog();
		myAnimal.makeSound();
		// myAnimal.wagTail();   // -> Error발생
	}// 업캐스팅은 특히 다형성을 활용할 때 주로 사용
}
```

**`Animal`** 클래스는 **`makeSound()`** 메서드를 가지고 있습니다. 이 클래스는 부모 클래스로 사용될 것입니다.

**`Dog`** 클래스는 **`Animal`** 클래스를 상속받은 자식 클래스입니다. **`makeSound()`** 메서드를 오버라이딩하여 재정의하고, **`wagTail()`** 메서드를 추가로 가지고 있습니다.

**`Upcasting`** 클래스의 **`main()`** 메서드에서는 **`Animal`** 객체인 **`myAnimal`**을 선언하고, 이 객체에 **`new Dog()`**로 **`Dog`** 클래스의 객체를 할당합니다. 이때, 업캐스팅이 자동으로 이루어집니다. 즉, **`Dog`** 객체는 **`Animal`** 객체로 취급됩니다.

**`myAnimal.makeSound()`**를 호출하면, 실제로 **`Dog`** 클래스의 오버라이딩된 **`makeSound()`** 메서드가 호출됩니다. 결과적으로 "Dog is barking"이 출력됩니다.

하지만 **`myAnimal`**은 **`Animal`** 타입으로 선언되었기 때문에 **`wagTail()`** 메서드에는 접근할 수 없습니다. 이는 업캐스팅된 객체는 부모 클래스의 멤버들에만 접근할 수 있다는 제약을 나타냅니다.

**업캐스팅**은 다형성을 활용할 때 주로 사용되는 개념입니다. 부모 클래스 타입으로 선언된 변수에 여러 자식 클래스의 객체를 할당하여, 공통된 부모 클래스의 멤버들을 일관되게 사용할 수 있습니다. 이를 통해 코드의 유연성과 확장성을 높일 수 있습니다.

<hr/>

### DownCasting.java   -  다운캐스팅

```java
class Parent {
	public void sayHello() {
		System.out.println("Hello from Parent");
	}
	public void sayGoodbye() {
		System.out.println("asdf");
	}
}
class Child extends Parent {
	public void sayHello() {
		System.out.println("Hello from Child");
	}
	public void sayGoodbye() {
		System.out.println("Goodbye from Child");
	}
}

public class Downcasting{
	public static void main(String[] args) {
		Parent p = new Child();		// 업캐스팅
		p.sayHello(); 				// 출력 : "Hello from Child"
		
		if (p instanceof Child) {	// p를 Child타입으로 캐스팅하겠다.
			Child c = (Child) p;	// 다운캐스팅
			c.sayGoodbye(); 		// 출력 : "Goodbye from Child"
		}
	}
}
// Parent p = new Child();		// 업캐스팅
// Child c = (Child) p;			// 다운캐스팅
```

**`Parent`** 클래스와 **`Child`** 클래스가 정의되어 있습니다. **`Parent`** 클래스에는 **`sayHello()`**과 **`sayGoodbye()`**라는 두 개의 메서드가 있고, **`Child`** 클래스는 **`Parent`** 클래스를 상속받아서 이들 메서드를 오버라이딩합니다.

**`Downcasting`** 클래스의 **`main()`** 메서드에서는 업캐스팅과 다운캐스팅을 보여줍니다.

먼저, **`Parent p = new Child();`**로 업캐스팅이 이루어집니다. 이는 자식 클래스(**`Child`**)의 객체를 부모 클래스(**`Parent`**)의 타입으로 참조하는 것입니다. 이후 **`p.sayHello()`**를 호출하면, 메서드 오버라이딩으로 인해 "Hello from Child"가 출력됩니다. 이는 동적 바인딩에 의해 실제 객체인 **`Child`**의 **`sayHello()`**가 호출되기 때문입니다.

다음으로, **`p`**를 **`Child`** 타입으로 다운캐스팅하기 전에 **`instanceof`** 연산자를 사용하여 **`p`**가 **`Child`** 클래스의 인스턴스인지 확인합니다. 이를 통해 다운캐스팅이 안전하게 이루어질 수 있는지 확인합니다. **`p`**가 **`Child`** 클래스의 인스턴스라면, 다운캐스팅이 가능하고 그렇지 않다면 다운캐스팅을 수행하지 않습니다.

다운캐스팅을 수행하기 위해 **`(Child) p`**와 같이 타입 변환을 명시적으로 수행합니다. 그리고 **`c.sayGoodbye()`**를 호출하면, 메서드 오버라이딩으로 인해 "Goodbye from Child"가 출력됩니다.

**다운캐스팅**은 업캐스팅된 객체에만 적용할 수 있으며, 실제 참조되는 객체의 타입을 명시적으로 지정하여 자식 클래스의 필드와 메서드에 접근할 수 있습니다. 하지만 다운캐스팅은 항상 안전하게 이루어지지 않을 수 있으므로 **`instanceof`**를 사용하여 실제 참조하는 객체의 타입을 확인하는 것이 좋습니다.